# ПРАКТИКА 1

- [ПРАКТИКА 1](#практика-1)
  - [Подготовка программного окружения для работы с Роботом](#подготовка-программного-окружения-для-работы-с-роботом)
  - [**Технология проектирования "сверху вниз"**](#технология-проектирования-сверху-вниз)
  - [Разбор задачи 2](#разбор-задачи-2)
    - [**Декомпозиция задачи на уровне псевдокода**](#декомпозиция-задачи-на-уровне-псевдокода)
    - [**Программный код главной функции**](#программный-код-главной-функции)
    - [**Реализация вспомогателных функций**](#реализация-вспомогателных-функций)
    - [**Запуск и отладка программного кода**](#запуск-и-отладка-программного-кода)

-----------------------

[<< README](../README.md)

------------------------

## Подготовка программного окружения для работы с Роботом

См. [здесь](https://github.com/Vibof/HorizonSideRobots.jl/blob/master/content/setup.md)

## **Технология проектирования "сверху вниз"**

Содержание этой технологии было разъяснено [в Лекции 1](Лекция-1.md).

Для её практического усвоения продолжим решение задач.

## Разбор задачи 2

(задача 1 была разобрана на лекции)

ДАНО: Робот - в произвольной клетке поля (без внутренних перегородок и маркеров)

РЕЗУЛЬТАТ: Робот - в исходном положении, и все клетки по периметру внешней рамки промакированы

Перейдем к решению.

### **Декомпозиция задачи на уровне псевдокода**

```julia
function mark_frame_perimetr!(r::Robot)
    дойти до самого Юга и вернуть сделанное число шагов
    дойти до самого Запада и вернуть сделанное число шагов
    #УТВ: Робот - в Юго-Западном углу

    for sidе - перебор всех 4-х сторон горизонта в ПРАВИЛЬНОМ порядке
        маркировать все клетки, кроме первой, в напраленнии side 
    end 
    #УТВ: По всему периметру прямоугольника стоят маркеры

    сделать уже известное число шагов на Север
    сделать уже известное число шагов на Восток
    #УТВ: Робот - в исходном положении
end
```

### **Программный код главной функции**

Вот соответствующий код главной функции на Julia

```julia
function mark_frame_perimetr!(r::Robot)
    num_vert = moves!(r, Sud)
    num_hor = moves!(r, West)
    #УТВ: Робот - в Юго-Западном углу

    for sidе in (Nord, Ost, Sud, West)
        putmarkers!(r, side)
    end
    #УТВ: По всему периметру стоят маркеры

    moves!(r, Nord, num_vert)
    moves!(r, Ost, num_hor)
    #УТВ: Робот - в исходном положении
end
```

### **Реализация вспомогателных функций**

```julia
function moves!(r::Robot, side::HorizonSide)
    num_steps=0
    while isborder(r,side)==false
        move!(r,side)
        num_steps+=1
    end
    return num_steps
end

function moves!(r::Robot,side::HorizonSide,num_steps::Int)
    for _ in 1:numsteps # символ "_" заменяет фактически не используемую переменную
        move!(r,side)
    end
end
```

Последние две функции имют одинаковые имена, но различаются количеством своих аргументов, поэтому `Julia` сумеет разобраться какую из них и когда надо вызывать. Это свойство языка называется **множественной диспетчеризацией**. Далеко не все языки программирования обладают этим свойством, например, в `Python` так сделать было бы нельзя.

Следующая функция уже была нами реализована при решении самой первой задачи (см. пример, разбиравшийся на 1-ой леции). И мы могли бы этим сейчас воспользоваться, но для этого надо было бы эту функцию сначала поместить в отдельный библиотечный файл, в котрый мы могли бы помещать также и другие универсально полезные функции. А затем этот библиотечный файл можно было бы использовать в других файлах с помощью функции `include`. Но пока еще мы этого не сделали, то нам придется написать ее повторно (хотя, конечно, это не правильно).

```Julia
function putmarkers!(r::Robot, side::HorizonSide)
    while isborder(r,side)==false
        move!(r,side)
        putmarker!(r)
    end
end
```

-----------------

[<< к началу](#практика-1)

### **Запуск и отладка программного кода**

Все эти определения должны быть помещены в отдельный файл (в этом файле мы и должны были сразу и писать их). Пусть этот файл называется "example-1.jl"

Тогда, что бы приступить к отладке программы, необходимо поместить все наши определения в пространство имен REPL. Для этого из REPL следует выполнить функцию

```julia
julia> include("examle-2.jl")
```

После этого определения всех функций из файла "example-2.jl" становятся известными в пространстве REPL, и поэтому любую из этих функций теперь можно вызвать на исполнение. В частности, вызов главной функции будет выглядеть так:

```julia
julia> mark_frame_perimetr!(r)
```

И если после этого в программу придется вносить какие-либо изменения, то, после сохранения результатов редактирования, необходимо будет снова выполнить функцию include, а затем уже вызывать на исполнение нужную функцию из соответствующего файла. 

Но с самого начала, конечно, мы должны были еще сделать

```julia
julia> using HorizonSideRobots

julia> r=Robot(animate=true)
```

Модуль HorizonSideRobots экспортирует перечисление HorizonSide, содержащее символы Nord, Sud, Ost, West,  и определения следующих функций:

```julia
    moves!(::Robot, ::HorizonSide)
    moves!(::Robot, ::HorizonSide, ::Int)
    find_border!(::Robot, ::HorizonSide, ::HorizonSide)
    inverse(::HorizonSide)
    putmarkers!(::Robot, ::HorizonSide)
    putmarkers!(r, direction_of_movement, direction_to_border)
```

После этого уже следует приступить к отладке программы. Для этого лучше всего придерживаться технологии отладки "снизу вверх", суть которой была изложена [здесь](https://github.com/Vibof/Robot/blob/master/example.md).

-----------------

[<< к началу](#практика-1)
