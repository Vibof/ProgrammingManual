# Справочная информация о некоторых самых первостепенных командах git

- [Справочная информация о некоторых самых первостепенных командах git](#справочная-информация-о-некоторых-самых-первостепенных-командах-git)
  - [Создание локального репозитория путём клонирования удаленного репозитория](#создание-локального-репозитория-путём-клонирования-удаленного-репозитория)
  - [Индексирование файлов (помещение файлов в индекс репозитория)](#индексирование-файлов-помещение-файлов-в-индекс-репозитория)
  - [Отмена индексирования файла (извлечение файла из индекса репозитория)](#отмена-индексирования-файла-извлечение-файла-из-индекса-репозитория)
  - [Фиксация внесённых в репозиторий изменений](#фиксация-внесённых-в-репозиторий-изменений)
  - [Возврат к последнему зафиксированному состоянию файла](#возврат-к-последнему-зафиксированному-состоянию-файла)
  - [Синхронизация удалённого репозитория с локальным репозиторием](#синхронизация-удалённого-репозитория-с-локальным-репозиторием)
  - [Удаление файлов из репозитория](#удаление-файлов-из-репозитория)
  - [Настройка системы на игнорирование некоторых файлов](#настройка-системы-на-игнорирование-некоторых-файлов)
  - [Переименование файлов репозитория](#переименование-файлов-репозитория)
  - [Просмотр состояния файлов](#просмотр-состояния-файлов)
  - [Редактирование файлов удалённого репозитория несколькими пользователями одновременно](#редактирование-файлов-удалённого-репозитория-несколькими-пользователями-одновременно)
  - [Возникновение конфликтной ситуации и простейший способ её разрешения](#возникновение-конфликтной-ситуации-и-простейший-способ-её-разрешения)
  - [Профессиональный способ разрешения конфликтов](#профессиональный-способ-разрешения-конфликтов)

В этом разделе будут описаны некоторые команды git в минимально необходимом для организации учебного процесса объёме.

Изучение этого небольшого раздела позволит совершить «быстрый старт» в git.

Внешне репозиторий представляет собой обычную папку с файлами. Отличительной её особенностью является наличие в ней подпапки `.git`, котороая создается сиcтемой git автомаически (в OC Windows 10 и Unix-like ОС указанная папка является скрытой). Эта папка используется системой для своих нужд и не предназначена для редактирования рядовым пользователем. 

Всё остальное содержимое папки репозитория (за пределами `.git`) представляет собой так называемую **рабочую копию**, в которой производятся все манипуляции с содержимым репозитория. Рабочая копия отражает (обычно актуальный, но может и какой-то прошлый) срез репозитория.

## Создание локального репозитория путём клонирования удаленного репозитория

Клонирование производится командой:
```
  > git clone URI [папка]
```
где *URI* — (сетевой) путь к удалённому репозиторию, а *папка* — не обязательное для указания имя папки, в которую будет склонирован репозиторий. Если имя папки не указывать, то будет использовано название репозитория; сама папка при необходимости будет создана автоматически.

## Индексирование файлов (помещение файлов в индекс репозитория)

В процессе работы в папке репозитория неизбежно будут создаваться новые файлы, а может быть, и папки с файлами.

Так если в папку репозитория будет добавлен какой-либо новый файл, например, файл `foo.jl`, то система git ещё не начнёт считать его частью репозитория. Чтобы этот файл был включён в репозиторий и стал отслеживаться git, его следует **проиндексировать**. Для этого нужно выполнить команду:
```
  > git add foo.jl
```
После этого данный файл/папка помещается в **индекс репозитория** и становится его (пока ещё не зафиксированной) частью. В индексе накапливаются данные с целью их последующей фиксации (см. ниже).

## Отмена индексирования файла (извлечение файла из индекса репозитория)

Убрать файл из индекса можно командой `git reset ...`, например
```
  > git reset foo.jl
```

Содержимое файла при этом никак не затрагивается.

## Фиксация внесённых в репозиторий изменений

Только что роиндексированные файлы ещё не зафиксированы системой в том состоянии, в котором они находятся в данный момент. То есть, если незафиксированный файл, например, удалить, то git не сможет его восстановить.

Фиксация состояний репозитория (содержащихся в нём файлов) требуется, прежде всего, чтобы в процессе работы над проектом всегда оставалась возможность вернуться («откатить», англ. rollback) к любому ранее зафиксированному состоянию. В git разработчики обмениваются друг с другом зафиксированными наборами изменений («**коммитами**») путём команд `git pull` и `git push` — для загрузки данных с удалённого сервера в локальный репозиторий и наоборот, соответственно (см. ниже).

Незафиксированный проиндексированный файл можно отредактировать. Однако если зафиксирована будет именно проиндексированная версия файла, а не текущая (после редактирования). С помощью команды `git status` можно проверить, остались ли какие-то непроиндексированные файлы.

Для фиксации текущего состяния репозитория (всех проиндексированных файлов) необходимо выполнить команду `git commit`, например:
```
  > git commit -m "краткое описание внесённых изменений"
```
здесь параметр `-m` означает, что следом за ним помещается однострочный коментарий, в котором кратко формулируется суть внесённых изменений. Например: 
```
  > git commit -m "удалены лишние файлы"
```
В результате все проиндексированные файлы будут зафиксированы в своём текущем состоянии («закоммичены») .

Если после этого данный файл снова будет отредактирован, то, чтобы зафиксировать его новое состояние, потребуется снова сначала его проиндексировать с помощью команды `git add`, а затем зафиксировать с помощью - `git commit`.

Если команда будет вызвана без параметра `-m`, как :
```
  > git commit
```
то при её выполнении автоматически откроется текстовый редактор (выбирается во время установки git, и этот выбор всегда можно изменить) с заготовкой для более пространного описания фиксируемых изменений.

Следует приучать себя писать краткие, но чёткие описания того, что было сделано. Такой навык является важной составляющей культуры хорошего программиста и жизненно необходим при работе в команде.

Пример многострочного комментария:
```
исправлены замечания преподавателя от 01.10.2020

- Повторяющийся в функциях move_to_*() код вынесен в общую функцию
  move_to_side().
  
- Исправлено поведение при старте робота от существующей стенки.
```

## Возврат к последнему зафиксированному состоянию файла

Чтобы вернуть испорченный файл/папку к состоянию, в котором он находился на момент последнего коммита, используется команда `git restore`, например:
```
  > git restore foo.jl
```
Следует, однако, помнить, что при использовании этой команды вернуть обратно затёртые ей изменения не получится, они пропадут насовсем.

## Синхронизация удалённого репозитория с локальным репозиторием

Последнее зафиксированное состояние репозитория может быть отправлено в удалённый репозиторий с помощью команды:
```
  > git push origin
```
где `origin` - это не обязательно указываемое стандартное имя удалённого репозитория, которое автоматически было связано с ним при выполнении клонирования (в принципе возможно присвоить удаленному репозитории и любое другое имя, но эта возможность актуальна только если приходится одновременно работать с несколькими удалёнными репозиториями). Если вы работаете только с одним удалённым репозиторием (а обычно это именно так), достаточно использовать команду `git push` без каких-либо дополнительных аргументов.

Важно помнить, что `push` отправляет только зафиксированные изменения, а не текущее состояние рабочей копии или индекс репозитория.

## Удаление файлов из репозитория

Если некоторый файл, например, `foo.jl`, уже находится в репозитории (отслеживается git), то, чтобы его удалить из репозитория, недостаточно будет простого удаления этого файла из папки репозитория: в этом случае git про файл не «забудет», и впоследствии он может появиться снова. Чтобы пометить такой файл для удаления из репозитория потребуется команда:
```
  > git rm foo.jl
```

После фиксации изменений файл будет считаться удалённым и  не будет появляться в рабочей копии. Однако все ранее зафиксированные его версии будут по-прежнему храниться в репозитории, и будут доступны для извлечения.

Чтобы удалить папку со всем её содержимым, нужно добавить к команде ключ `-r`, например:
```
  > git rm -r unusedfolder
```

## Настройка системы на игнорирование некоторых файлов

Наряду с отслеживаемыми файлами в папке репозитория могут присутствовать ещё и какие-то вспомогательные файлы, собственно к репозиторию не относящиеся, отслеживать которые не требуется. Для того чтобы они по ошибке не попадали в число отслеживаемых системой файлов, в папке репозитория может быть создан файл `.gitignore`, в котором имена этих файлов  быть прописаны. Подробнее см. документацию по [.gitignore](https://git-scm.com/docs/gitignore).

## Переименование файлов репозитория

При необходимости переименовать файл (в частности, перенести его в другую папку) сначала можно создать его копию с новым именем, потом добавить эту копию в репозиторий, а затем старый файл удалить с помощью `git rm`. А можно воспользоваться для этого специальной командой `git mv`. Например, следующая команда переименует файл `foo.jl` в `bar.jl` и запишет сведения об этом в индекс:
```
  > git mv foo.jl bar.jl
```
А эта команда перенесёт файл `bar.jl` из папки `foo` в папку `buz`:
```
  > git mv foo/bar.jl buz/
```
Наравне с файлами можно переименовывать/перемещать и папки.

## Просмотр состояния файлов

Чтобы выяснить текущее состояние файлов в рабочей папке (изменены, проиндексированы, добавлены, удалены и так далее), следует выполнить команду:
```
  > git status
```
Данная команда покажет, какие (не игнорируемые) файлы были добавлены, изменены, либо не внесены в репозиторий.

## Редактирование файлов удалённого репозитория несколькими пользователями одновременно

Прежде всего следует отметить, что интерфес GitHub позволяет прямо в web-браузере открыть любой содержащийся в репозитории файл, внести в него изменения и зафиксировать их. Однако делать это надо с большой осмотрительностью, поскольку результаты таких изменений, само собой разумеется, не будут автоматически синхронизироваться с локальными репозиториями.

Аналогичная ситуация может возникнуть, если право редактировать удалённый репозиторий получают одновременно несколько пользователей, и хотя бы один из них своим правом воспользуется. Тогда локальные репозитории остальных пользователей окажутся уже рассинхронизированными с удалённым репозиторием.

Для исправления такой ситуации из каждого рассинхронизированного локального репозитория следет выполнить команду:
```
  > git pull
```
При этом могут возникнуть конфликтные ситуации, решение которых описано ниже.

## Возникновение конфликтной ситуации и простейший способ её разрешения

Если в результате нарушения синхронизации с удаленным репозиторием (например, по причинам, описанным в предыдущем пункте, или если в двух локальных репозиториях вносятся изменения в одни и те же строчки одних и тех же файлов), в любом рассинхронизированном локальном репозитории вовремя не выполнить команду `pull`, но при этом внести какие-либо изменения, то окажется, что невозможно выполнить ни команду `push`, ни команду `pull`. 

В этом случае в ходе выполнения команды `pull` система git сообщит о существовании конфликтов, с перечислением проблемных файлов. 

Ниже приведён пример конфликта с файлом `NameModule.jl`:
```
> git pull
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Распаковка объектов: 100% (3/3), 9.95 KiB | 1.42 MiB/s, готово.
Из github.com:grayed/Robot
   97fb7e2..5fe4192  master     -> origin/master
Автослияние NameModule.jl
КОНФЛИКТ (содержимое): Конфликт слияния в NameModule.jl
Не удалось провести автоматическое слияние; исправьте конфликты и сделайте коммит результата.
```

Простейшим выходом из этой ситуациии является повторное клонирование удалённого репозитория в какое-то новое место. Затем следует привести содержащиеся в созданном новом локальном репозитории файлы к требуемуму виду, сравнивая их с файлами из старого локального репозитория. Когда новый репозиторий будет приведён к требуемому виду, внесённые в него изменения необходимо будет фиксировать командой `git commit`, и уже затем внесённые изменения могут быть отправлены на сервер командой `git push`. После этого старый локальный репозиторий можно удалить.

## Профессиональный способ разрешения конфликтов

Этот путь используется профессиональными разработчиками чаще всего.

Прежде всего следует  проблемные файлы. Места конфликтов будут помечены в них специальными маркерами, которые по завершении редактирования нужно будет убрать. Например:

```julia
module NameModule

function start!(r:: Robot)
    while isborder(r, Sud) == false
        move!(r, Sud)
    end
<<<<<<< HEAD
    while isborder(r, Ost) == false
        move!(r, Ost)
=======
    while isborder(r, West) == false
        move!(r, West)
>>>>>>> master
    end
end

end
```

Маркер `=======` разделяет строки, присутствующие в локальном репозитории и пришедшие извне. Нужно отредактировать файл так, чтобы остались только нужные строки, например:

```julia
module NameModule

function start!(r:: Robot)
    while isborder(r, Sud) == false
        move!(r, Sud)
    end
    while isborder(r, West) == false
        move!(r, West)
    end
end

end
```

Какие именно строки следует оставить (а, может, вообще нужно вместо них вписать что-то третье) — известно только вам, git не в состоянии это определить — это и является причиной конфликта. В тех случаях, когда локальные и входящие изменения затрагивают разные файлы, или разные участки одного файла, git сама справляется.

После этого командой `git add ...` пометить файл как исправленный и, когда со всеми проблемными файлами будет покончено (это покажет `git status`), зафиксировать внесённые изменения командой `git commit`. После этого рекомендуется сразу сделать `git push`, чтобы возникшие несогласованные изменения не пришлось сводить воедино вновь при следующей попытке выполнить `git pull`.

