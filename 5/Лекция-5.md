# ЛЕКЦИЯ 5

- [ЛЕКЦИЯ 5](#лекция-5)
  - [Обобщенное программирование](#обобщенное-программирование)
    - [Иерархия типов Julia, конкретные и абстрактные типы](#иерархия-типов-julia-конкретные-и-абстрактные-типы)
    - [Пример разработки обобщенной функции](#пример-разработки-обобщенной-функции)
    - [Принцип аннотирования типов аргуметов функции](#принцип-аннотирования-типов-аргуметов-функции)

## Обобщенное программирование

**Обобщенное программирование** - это еще один способ программировать так, чтобы один раз написанный код мог многкратно использоваться повторно, причем максимально широко. 

Обобщенное программирование реализуется на основе так называемых **обобщенных функций**.

Функция с аргументом (хотя бы одним) называется **обобщенной**, если она написана так, что ее код может использоваться при разных типах этого ее аргумета. Причем так, что если аргумент имеет тип A, то фактически будут выполняться действия, соответствующие типу A, а если тип аргумента B, то - действия, соответствующие типу B. Причем тело самой функции (код функции) будет в обоих случаях одно и то же. 

Таким образом, любая обобщенная функция должна допускать, чтобы фактическое значение хотя бы одного из ее параметров могло быть разных типов.

### Иерархия типов Julia, конкретные и абстрактные типы

В языке Julia типы подразделяются на **конкретные типы** и **абстрактные типы**. 

Примерами конкретных типов являются все знаковые целые типы: `Int8`, `Int16`, `Int32`, `Int` (это синоним `Int64`), все беззнаковые целые типы: `UInt8`, `UInt16`, `UInt32`, `UInt64`, тип длинных целых `BigInt`, типы с плавающей точкой: `Float16`, `Float32`, `Float64`, `BigFloat`, логический тип `Bool` и другие типы.

Типы Robot, HorizonSide являются примерами **пользовательских** (сконструированных) конкретных типов. Существут разные способы конструирования новых типов, и с этими способами мы постепенно познакомимися. Например,

Примерами абстрактных типов являются тип всех знаковых целых `Signed`, тип всех беззнаковых целых `Unsigned`, тип всех целых `Integer`, тип всех чисел с плавающей точкой `AbstractFloat`, тип всех вещественных чисел `Real`, тип чисел всех видов `Number`, и другие.

Каждое размещаемое в памяти значение обязательно имеет какой-то конкретный тип. Значений абстрактных типов не бывает. Абстрактные типы используются для того, чтобы существовала иерархия типов. В этом смысле любой конктретный знаковый тип есть подтип `Signed`, а `Signed` - есть подтип `Integer`, а последний есть подтип `Real`, который, в свою очередь, есть подтип `Number`.

Во главе всей иерархии типов находится абстрактный тип `Any`.

Так вот, хотя бы один аргумент обобщенной функции должен быть аннотирован каким-либо абстрактным типом. Явное аннотирование типом Any не требуется, т.к. такая аннотация подразумевается всегда, когда тип аргумента функции явно не указывается.

Некторые абстрактные типы являются параметрическими, например, тип комплексных чисел `Complex` является абстрактным, а тип комплексных чисел, базирующийся на каком-либо конкретном вещественном типе, например, `Complex{Float64}`  
или `Complex{Int}`,  является уже конкретным. Т.е. параметрические типы имеют патаметр (или несолько параметров), который должен принимать значение какого-либо конкретного типа.

Чтобы получить значение типа какого-либо выражения, в частности переменной, следует воспользоваться специальной функцией `typeof`.

Параметрическими типами также являеются кортеж значений любых типов `Tuple` кортеж однотипных элементов `NTuple`, а также одномерный массив `Vector`. Например:
```julia
julia> typeof((2,Nord)) 
Tuple{Int,HorizonSide}
```
или
```julia
julia> typeof((Nord,Ost))
Tuple{Int,Int}
```
при этом `Tuple{Int,Int}` - это тоже самое, что `NTuple{2,Int}`,

или
```julia
julia> typeof([10,20,30])
3-element Array{Int64,1}: …
```
при этом `Array{Int64,1}` и `Vector{Int64}` - это одно и то же.

В отличие от векторов (массивов) элементы кортежей неизменяемы (нельзя присвоить элементу кортежа новое значение).


Проверить иерархическую соподчиненность любых двух типов можно с помощью операции `<:`, например,
```julia
julia> Int <: Integer
true

julia> Int >: Integer
false
```

Если `T1<:T2` и `T1 >:T2`, то типы `T1` и `T2` это обозначения одного и того же типа. Например, `Tuple{Int,Int}<:NTuple{2,Int}` и `Tuple{Int,Int}>:NTuple{2,Int}`.

При этом имеют место следующие важные соотношения типов
Пусть T1 <: T2, тогда верно, что NTuple{N,T1} <: NTuple{N,T2} (N - любое целое), но Vector{T1}<:Vector{T2} - это, вообще говоря, не верно. 

Например:
```julia
julia> Vector{Int} <: Vector{Int}
true
```
но
```julia
julia> Vector{Int} <: Vector{Integer}
false
julia> Vector{Int} >: Vector{Integer}
false
```
Верным будет только
```julia
julia> Vector{Int} <: Vector{<:Integer}
true
```
где `Vector{<:Integer}` читается как вектор целых чисел ЛЮБЫХ ТИПОВ, производных от типа `Integer`, это также можно записать как `Vector{T} where T<:Integer`. 

Последнее связано с тем, что если бы из T1 <: T2 всегда бы следовало, что Vector{T1} <: Vector{T2}, то в некоторых случаях это бы приводило к противоречиям с точки зрения системы типов.

Для выяснения того, какой тип для данного типа является родительским, есть функция `supertype`, а для получения списка дочерних типов данного типа имеется функция `subtypes`. Этими следует пользоваться, когда требуется прояснить положение какого-либо типа в иерархии типов.

Если есть два типа T1 и T2, каждый из котрых может быть как абстрактным, так и конкретным, то их объединение `Union{T1,T2}`, даст новый пользовательский абстрактный тип (построить пересечение типов в Julia нельзя). 

### Пример разработки обобщенной функции 

Если все аргументы функции аннотированы какими-либо конкретными типами, то такая функция является узко **специализированной** (не обобщенной). 

До сих пор, когда мы аннотировали типы аргументов наших функций, используя конкретные типы, то получали всегда именно такие узкоспецированные функции. Однако такой подход к проектированию функций часто не оправдан.

Рассмотрим задачу 13:
    ДАНО: Робот - в произвольной клетке ограниченного прямоугольной рамкой поля без внутренних перегородок и маркеров.

    РЕЗУЛЬТАТ: Робот - в исходном положении в центре косого креста (в форме X) из маркеров.

Решение могло бы быть, например, таким.

```julia
#=
 Если в эту функцию дополнительно передавать кортеж направлений, то, если не аннотировать тип этого дополнительного параметра, эта функция получилась бы обобщенной
=#
function mark_kross_x(r::Robot)
    for side in ((Nord,Ost),(Sud,Ost),(Sud,West),(Nord,West))
        putmarkers!(r,side)
        move_by_markers!(r,inverse(side))
    end
    putmarker!(r)
end

# Если не аннотировать тип параметра side, то эта функция стала бы обобщенной
putmarkers!(r::Robot, side::NTuple{2,HorizonSide}) = while isborder(r,side)==false move!(r,side) end

# Этот метод функции isborder дает ее специализацию для типа NTuple{2,HorizonSide} по параметру side
isborder(r::Robot,side::NTuple{2,HorizonSide}) = (isborder(r,side[1] || isborder(r,side[2]))

#Этот метод функции HorizonSideRobots.move! дает ее специализацию типа NTuple{2,HorizonSide} по параметру side
HorizonSideRobots.move!(r::Robot,side::NTuple{2,HorizonSide}) = for s in side move!(r,s) end

#=
 Если не аннотировать тип параметра side, то эта функция стала бы обобщенной (но специализация для типа HorizonSide сохранилась бы)
=#
move_by_markers!(r::Robot,side::NTuple{2,HorizonSide}) = while ismarker(r) move!(r,side) end

# Этот метод функции inverse дает ее специализацию для типа NTuple{2,HorizonSide} по параметру side
inverse(side::NTuple{2,HorizonSide}) = (inverse(side[1]),inverse(side[2]))
```
Таким образом, если бы мы с самого начала стремились бы писать обобщенно, то при решении задачи 1 у нас получился бы код

```julia
function mark_kross(r::Robot,sides)
    for side in sides
        putmarkers!(r,side)
        move_by_markers!(r,inverse(side))
    end
    putmarker!(r)
end

putmarkers!(r::Robot,side) = while isborder(r,side)==false move!(r,side) end
move_by_markers!(r::Robot,side) = while ismarker(r) move!(r,side) end
inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4))
```

Если этот код, с определениями этих 4-х функций находится в отдельном файле, то тогда при решении задачи 13 мы могли бы его использовать без всяких изменений, воспользовавшись функцией `include`. Но при этом, уже в новом файле с решением задачи 13, нам пришлось бы дополнительно  дать еще следующие три определения, специализирующих нужным образом  соответствующие функции:
```julia
isborder(r::Robot,side::NTuple{2,HorizonSide}) = (isborder(r,side[1] || isborder(r,side[2]))
HorizonSideRobots.move!(r::Robot,side::NTuple{2,HorizonSide}) = for s in side move!(r,s) end
inverse(side::NTuple{2,HorizonSide}) = (inverse(side[1]),inverse(side[2]))
```
В результате ранее определенная (обобщенная) функция  mark_kross(r::Robot,sides) решала бы и задачу 13. 

Больше того, если бы потребовалось, например, расставить маркеры еще и в форме 8-конечного креста, то уже вообще ничего программировать бы не потребовалось, достаточно было бы просто вызвать функцию `mark_kross` с фактическим параметром в позиции side имеющем значение 8-элементного кортежа `(Nord,(Nord-Ost),Ost,(Sud,Ost),Sud,(Sud,West),West,(Nord,West))`. Заметим, что тип этого кортежа есть `Tuple`, а не NTuple, т.к. составляющие его элементы имеют разный тип.   

Можно было бы даже совсем отказатьса от аннотирования типа аргумента `side` (с мыслью о том, что вдруг года-нибудь понадобится понимать под side что-нибудь отличное от того, что мы понимаем сейчас; например, в принципе, в какой-то другой ситуации направление может задаваться и словами "лево", "право"):
```julia
isborder(r::Robot,side) = (isborder(r,side[1] || isborder(r,side[2]))
HorizonSideRobots.move!(r::Robot,side) = for s in side move!(r,s) end
inverse(side) = (inverse(side[1]),inverse(side[2]))
```
И это делало бы последние три функции тоже обобщенными (правда мы пока точно не знаем, когда потенциал такого обобщения сможет быть реализованным, но мы сделали так на всякий случай, а вдруг это пригодится).

Исходя из всего сказанного, можно предположить, что на всякий случай и от аннотации типа аргумента r в определениях наших обобщенных функций  лучше отказаться ([см. еще ниже](#принцип-аннотирования-тпов-аргуметов-функции)). 

В итоге получаем следующий обобщенный код (теперь уже и по аргументу r)

```julia
function mark_kross(r,sides)
    for side in sides
        putmarkers!(r,side)
        move_by_markers!(r,inverse(side))
    end
    putmarker!(r)
end

putmarkers!(r,side) = while isborder(r,side)==false move!(r,side) end
move_by_markers!(r,side) = while ismarker(r) move!(r,side) end
inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4))
```

А при решении задачи 13 дополнительно к этому получим
```julia
isborder(r::Robot,side::NTuple{2,HorizonSide}) = (isborder(r,side[1] || isborder(r,side[2]))
HorizonSideRobots.move!(r::Robot,side::NTuple{2,HorizonSide}) = for s in side move!(r,s) end
inverse(side::NTuple{2,HorizonSide}) = (inverse(side[1]),inverse(side[2]))
```
ЗАМЕЧАНИЕ.
Может показаться, что отказ от аннотирования типов аргументов функций существенно снизит надежность программного кода из-за того, что теперь возможны ошибки, связанные с передачей функциям параметров не тех типов, которые требуются. Однако на практике это не так, ткого рода ошибки быстро обнаружатся, как только дело дойдет до выполения узкоспециализированных методов в "глубине" функции. Просто стек выводимых сообщений об ошибках будет теперь получаться несколько длиннее, но до истинных причин такого рода ошибок "докопаваться" все-равно будет не так уж и сложно.

Таким образом, в файл roblib.jl имеет смысл помещать определения функций в как можно более обобщенном виде, что расширит сферу их применимости.

### Принцип аннотирования типов аргуметов функции 

**Общий принцип может быть сформулирован так: при аннотировании аргументов функции конкретные типы использовать только тогда, когда в теле этой функции НЕПОСРЕДСТВЕННО вызываютя конструкторы этих типов.**

**Во всех остальных случаях следует аргументы функции аннотировать АБСТРАКТНЫМИ типами по возможности более высогого иерархического уровня (в пределе воообще не аннотировать, что фактически будет означать использование типа Any). Важно лишь, чтобы КОММАНДНЫЙ ИНТЕРФЕЙС фактических объектов, передаваемых в функцию при ее вызове, содержал все операции (действия), используемые в определении функции (но содержание этих операций всегда определяется ФАКТИЧЕСКИМ типом объекта).**

На первый взгляд может показаться, что функция будет получаться обобщенной лишь когда она непосредственно не вызывает узкоспециалированных подфункций (или операций). Но на самом деле надо иметь ввиду, что **специализация любой подфункции всегда может быть расширена за счет добавления (во вне) новых методов для нее**. И поэтому, если только мы не ограничим слишком жестким ограничением допустимых типов аргументов главной функции (путем неудачного аннотирования типов), то тогда такая функция будет иметь потенциал для обобщения. 

Заранее часто бывает трудно предсказать где этот потенциал может быть реализован. Просто надо стремиться его сохранять, и когда-нибудь он может раскрыться неожиданным образом, позволив решить новую задачу почти без программирования.

В языке Julia аннотирование типов аргументов функции предназначено вовсе не для избавления от ошибок времени выполнения, связанных с неверными типами фактических параметров функции, как это имеет место в статических языках программирования, таких как С/C++. Такие ошибки, хотя и возможны, но они не представляют большой проблемы, т.к. в любом случае, в силу того, что компилятор в Julia динамический, они могут быть обнаружены лишь во время выполнения программы. Но даже если в момент вызова функции, типы параметров которой не были аннотированы, ошибка не будет обнаружена сразу, то она все равно обнаружится чуть глубже, когда дело дойдет до вызова подфункции, у которой не окажется метода, соответствующего ошибочному типу полученного функцией параметра.

Истинное назначение аннотирования типов в Julia в том, чтобы быть основой для механизма **множественной диспетчеризации**, который обеспечивается возможностью создавать новые специализации для функций (создавать новые методы для функций). В классических ООП языках программирования тоже есть аналогичная возможность перегрузки функции, но только она связывается лишь с первым аргументом функции (например, в языке Python этот аргумент принято называть self, а в языке С++ - this). Множественная же диспетчеризация распространяет такую возможность на все аргументы функции в совокупности, обеспечивая невероятно большую вариативность.

