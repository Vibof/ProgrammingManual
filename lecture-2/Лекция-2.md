# ЛЕКЦИЯ 2
СОДЕРЖАНИЕ
- [ЛЕКЦИЯ 2](#лекция-2)
  - [Уточнение понятия алгоритма](#уточнение-понятия-алгоритма)
  - [Что такое "правильная программа"](#что-такое-правильная-программа)
  - [Языки программирования и трансляция программы в машиный код](#языки-программирования-и-трансляция-программы-в-машиный-код)
    - [Классификация трансляторов](#классификация-трансляторов)
  - [Устройство и алгоритм работы компьютера](#устройство-и-алгоритм-работы-компьютера)
  - [Локальные и глобальные переменные](#локальные-и-глобальные-переменные)
    - [Статическая и динамическая типизация](#статическая-и-динамическая-типизация)
    - [Пример программы, использующей функции с локальными переменными](#пример-программы-использующей-функции-с-локальными-переменными)
    - [О использовании глобальных переменных](#о-использовании-глобальных-переменных)
    - [Использование программами компьютерной памяти](#использование-программами-компьютерной-памяти)

## Уточнение понятия алгоритма

В школьном курсе информатики обычно говорится, что **алгоритм** - это некоторая последовательность действий, дающаяя решение задачи.

Однако в этом определении остается неясным, о каких именно действиях идет речь. Подразумевается, что это должно быть известно в контексте каждой конкретной задачи.

В целом это так и есть, но все же здесь следует сделать следующее уточнение.

Прежде вего, отметим, что всякий **алгоритм** подразумевает некоторого **исполнителя**, которому алгоритм адресуется. Необходимо только сначала четко сформулировать, что же следует понимать под "исполнителем".

Под **исполнителем** понимается некоторое устройство (автомат), которое обладает следующими двумя атрибутами:
  - множеством внутренних состояний (не более чем счетным);
  - конечным множеством команд, которые исполнитель "умеет" исполнять.
При этом в каждый момент времени исполнитель находится в каком-то одном и только одном из своих состояний. Самопроизвольно перейти из одного состояния в другое исполнитель не может. Такие переходы возможны лишь при выполнении исполнителем некоторых из своих команд. Любая команда выполняются исполнителем тогда и только тогда, когда он получает на это предписание (сигнал) из вне.

Множество всех команд исполнителя называется его **командным интерфейсом**.

Если внимательно приглядеться, то становится ясно, что программист всегда имеет дело с каким-нибудь исполнителем. Будь то простые переменные в программе, программный модуль, объекты какого-либо типа (класса), любое внешнее устройство, управляемое компьютером, даже такие компоненты компьютера, как память или арифметико-логическое устройство процессора, аппаратным образом реализующее арифметические и логические операции, и т.п. - это все примеры исполнителей, ни с чем другим программист дела не имеет.

При этом если приходится иметь дело сразу с несколькими исполнителями, то, с формальной точки зрения, в совокупности их можно рассматривать как одного объединенного исполнителя. А именно, множество состояний этого объединенного исполнителя есть просто декартово произведение множеств состояний всех частных исполнителей, а его командный интерфейс будет объединением командных интерфейсов всех частных исполнителей.

Теперь мы уже можем дать более точное определение понятия алгоритма.

**Алгоритмом** называется *каким-либо образом* определенная *конечная* последовательность команд исполнителя, перводящая его из *заданного начального состояния* в *требумое конечное состояние*.

Здесь существенно, что не имеет значения, каким именно образом определена эта последовательность команд: в виде обычного текста, в виде формального теста, графическими диаграммами или математическими формулами. Сам алгоритм от этого не меняется.

Далее, поледовательность команд должна быть конечной, иначе алгоритм никогда бы не заканчивался, т.е. никогда бы не выдавал решения задачи (имеется в виду, что любая команда требует каких-то временных затрат).

"Заданное начальное состояние" и "требуемое конечное состояние" определяются некоторыми высказываниями, которые мы будем именовать - "ДАНО" и "РЕЗУЛЬТАТ", соответственно.

Такого рода высказывания всегда зависят от неявно присутствующей (подразумеваемой) переменной, значения которой принадлежат множеству всех состояний исполнителя. Иными словами, при некоторых состояниях эти высказывания имеют значение true, а при других, возможно, - false.

Такие высказывания, значения которых зависят от какой-либо переменной, в логике называют **предикатами** - по сути это условия.

Пример предиката: `x>0` - при одних значениях `x` это выскзывание верно, а при других - нет. Или другой пример: "Робот - у восточной границы поля" - при некоторых состояниях исполнителя "Робот на клетчатом поле", значение будет true, а при других - false.

Вот пример "ДАНО" и "РУЗУЛЬТАТ" для Робота, определяющие задание на разработку алгоритма:
    ДАНО: Робот - у восточной границы
    РЕЗУЛЬТА: Робот - у западной границы

## Что такое "правильная программа"

Пусть имеется некоторый алгоритм, определяемый предикатами "ДАНО" и "РЕЗУЛЬТАТ".

Пусть имеется какая-либо запись этого алгоритма. 

Любую конкретную запись алгоритма будем называть **программой**.

**Программа называется правильной**, если при любом начальном состоянии, удовлетворяющем условию "ДАНО", выполненяются пункты:
1) программа завершается за конечное число шагов (на каждом шаге выполняется одна из команд исполнителя);
2) достигнутое конечное состояние исполнителя удовлетворяет условию "РЕЗУЛЬТАТ".

Тут, конечно, мы упростили ситуацию, исключив из рассмотрения случаи, когда требуемое число шагов будет хотя и конечным, но непремлемо большим с практической точки зрения. А также, когда выполнение программы будет требовать слишком большой, превышающий технические возможности, объем памяти.

Таким образом, чтобы вполне удостоверится в правильности программы экспериментально, потребуется ее выполнить для каждого допустимого начального состояния. Но число допустимых состояний исполнителя может быть настолько большим, что это окажется практически не реализуемым.
Поэтому в таких случаях приходится продумывать систему тестов, которая будет охватывает лишь относительно небольшую часть всех возможных начальных состояний, но при этом проверять наиболее "критические" из них.

Другой подход к проверке правильности программы базируется на математических методах доказательства - это так называемое доказательное программирование.

## Языки программирования и трансляция программы в машиный код

Алгоритмы записываются на формальных языках, называемых языками программирования.

Языки программирования, близкие к языку машинных команд, называтся языками низкого уровня - это **ассемблеры** (для каждого типа процессора существует свой ассеммблер). Такие языки позволяют в максимальной степени учитывать особенности архитектуры процессора, и поэтому позволяют создавать наиболее эффективный исполняемый (машинный - его еще называют) код. Однако на таких языках очень тяжело выражать сложные человеческие мысли.

Для удобства выражения человеческих мыслей используются языки высокого уровня, такие как `Julia`, `Python`, `C/C++`, и очень многие другие.
Но при этом возникает проблема перевода с языков высокого уровня на язык машинных команд. Перевод с асеммблера на язык машинных команд - это задача тривиальная.

Перевод с языка программирования на язык машинных команд (язык процессора) - называется **трансляцией**.

Трансляция осуществляется с помощью специальных программ, называемых **трансляторами**.

### Классификация трансляторов

    ТРАНСЛЯТРЫ:
        - ИНТЕРПРЕТАТОРЫ
        - КОМПИЛЯТОРЫ:
          - СТАТИЧЕСКИЕ КОМПИЛЯТОРЫ
          - ДИНАМИЧЕСКИЕ КОМПИЛЯТОРЫ (JIT-компиляторы)

Интерпретаторы, грубо говоря, транслируют каждую отдельную строку исходного кода.
А компиляторы, преобразуют исходный код целиком в  машинные инструкции, при этом осуществляют оптимизацию кода. В результате скомпилированный код будет работать в десятки и сотни раз быстрее интерпретируемого.

При этом интерпретаторы, в отличие от компиляторов, обладают возможностями интерактивн работы с исходным кодом, что значительно упрощает и ускоряет процесс разработки программы, и легко контролировать все этапы ее выполнения.

Обычно выбор между интерпретируемым языком и копилируемым сводится к решению дилемы, что важнее: скорость и удобство проектирования, или скорость выполнения программы.

Кроме того, граница между интепретаторами и компиляторами на самом деле не такая уж четкая. Дело в том что современные интепретаторы на самом деле тоже компилируют исходный код в инструкции какой-либо **виртуальной машины** (т.е. машины, реализованной программной, являющейся некоторой программной надстройкой над реальным процессором). Например, есть виртуальная машина Java (JVM), у Python тоже есть своя витруальная машина. А инструкции соответствующей виртуальной машины уже интерпретируются, т.е. последовательно преобразуются в настоящие машинные инструкции. 

Тут все дело в том, насколько "далека" виртуальная машина от реального процессора. Если эта дистанция не велика, т.е. если вся оптимизация кода может быть выполнена на этапе компиляции в инструкции виртуальной машины, а эффективная трансляция этих инструкций в настояшие машинные коды - уже не представляет никакой проблемы, то такая трансляция на основе такой виртуальной машины будет порождать высокоэффективный код. Например, существует так называемая низкоуровневая виртуалная машина - LLVM (Low Level Virtual Machine). Многие современные компиляторы базируются на LLVM, в том числе и некоторые компиляторы C++.

При этом компиляция бывает двух видов - статическая и динамическая (JIT-компиляция - компиляция "на лету").
Статическая компиляция предполагает трансляцию до начала выполнения программы, а динамическая - трансляцию во время ее выполнения. Т.е. при динамической компиляции каждая отдельная функция, составляющая программу, или тело отдельного цикла транслируются при первом выполнении, а затем результат этой трансляции уже используется многократно. 

Такие динамические компиляторы, если они базируются на LLVM, способны порождать очень эффективный машинный код, и могут почти не уступать в этом статическим компиляторам. При этом динамическая компиляция позволяет иметь все интерактивные возможности, свойственные интерпретаторам. Таков, например, язык Julia. 

## Устройство и алгоритм работы компьютера

Основные элементы компьтера - это
 - ЦЕНТРАЛЬНЫЙ ПРОЦЕССОР
 - ПАМЯТЬ (опреативная память, ОЗУ)
 - УСТРОЙСТВА ВВОДА-ВЫВОДА (например: монитор, клавиатура, внешние носители информации), называемые также переферийными устройствами
 - ШИНА - это многожильный провод, по которому по специальному протоколу все перечисленные элементы обмениваются информацией
  
**Память** - на логическом уровне представляет собой последовательнсть байтов, в которой каждый байт имеет свой номер, называемый адресом. Есть 0-ой байт, 1-ый, ..., (2^N - 1)-ый, где N - разряность процессора. В этом смысле говорят, что адресное пространство - линейное. В современных компьютерах обычно N=64, но встречаются еще и 32-х разрядные машины.

Память служит для того, чтобы в ней, в едином адресном пространстве, размещались и программные коды и данные (это так называемая фоннеймановская архитектура, но бывает еще и гарвардская, в которой адресные пространства для машинных кодов и для данных разные). 

Программные коды размещаются обычно в непрерывном участке памяти в естественной последовательности, команда за командой.
При этом разные машинные инструкции могут иметь разную длину, т.е. некотрые из них занимают в памяти 1 байт, некоторые 2, некоторые - больше. Это происходит потому, что каждая машинная инструкция имеет свой код длиной в 1 байт, но число параметров у различных инструкций может быть разное.

В процессорах, кроме всего прочего, имеются специалные ячейки памяти, называемые регистрами. Физически регистры характеризуются тем, что позволяют с очень высокой скоростью записывать и считывать данные, много быстее ячеек обычной памяти. Регистры бывают общего назначения, их может быть довольно много, а есть специальные регистры. 
  
В частности в любом процессоре есть регистр, называемый командным регистром, или, по другому, - счетчиком команд. Часто его обозначают как PC (Program Counter). Он предназначен для того, чтобы в каждый момент времени в нем был записан алрес команды, которая будет выполняться на следующем шаге.

Алгоритм работы компьютера может быть представлен следующим нескончаемым циклом

    ПОВТОРЯТЬ БЕЗ КОНЦА:
        1) прочитать команду, находящуюся в памяти по адресу, содержащемуся в PC
        2) авеличить аддрес в PC на длину прочитанной команды
        3) выполнить прочитанную команду

Поскольку прочитанная команда может содержать инструкцию, приводящую к измению содержимого PC, записанный алгоритм позволяет реализовавать не только линейную последовательность инструкций, но также - и циклы и ветвения.

Рассмотренная схема работы компьютера, конечно, предельно упрощена. 

Во-первых, надо отметить, что программы, выполняемые на компьютере, обычно подразделяются на операционную систему (ОС), и прикладные программы, которые выполняются под управлением ОС. Операционная система может находится в фоновом режиме, передавая управление компьютером той или иной прикладной программе, или разделяя по определенному правилу машинное время между, как бы одновременно выполняемыми, прикладными прогарммами. Этот механизм мы здесь не рассматривали.

Во-вторых, приведенная схема работы компьютера не учитывает также возможность наличия многопроцессорной архитектуры. 

ЗАМЕЧАНИЕ.
В состав процессора входит так называемое арифметико-логическое усторйство, которое аппаратно реализует арифметические и логические опрерации. Ясно, что это устройство, в совокупности с некоторыми регистрами, является исполнителем, в  ом смысле, как это понятие было определено, со своим командным интерфейсом - набором процессорных инструкций. Однако компьютер в целом уже не является просто исполнителем, это **автоматически** работающее устройство, логика (алгоритм) работы которого была здесь рассмотрена.

## Локальные и глобальные переменные 

### Статическая и динамическая типизация
В таких языках программирования, как например, С/C++, где типы переменных объявляются заранее, тип пременной не может изменяться во время выполнения программы. Такая типизация называется статической.

В языках Julia и Python, напротив, типизация является динамической. Это означает, что фактически сама по себе переменная типа не имеет, а тип есть у значения, на которое в данный момент ссылается соответствующая переменная. Это также означает, что в следующий момент времени переменная можнт быть связана со значением уже другого типа. Для этого достаточно просто воспользоваться оператором присваивания. Такая гибкость в некоторых ситуациях может иметь преимущество, но это также может быть и источником замедления выполнения программы на языке Julia, т.к. нестабильность типа переменной может препятствовать компилятору сгенерировать эффективный код (для Pythona такой проблемы нет, потому что у него нет и эффективного компилятора). Поэтому это надо иметь ввиду.

Отсутствие явного объявления типов переменных в языках программирования вовсе не означает отсутствия в них типизации, просто тип может быть выведен из выражения, представляющее значение в правой части оператора присваивания. Этот выведенный тип и будет типом пременной. Выведение типов имеет место и в некоторых языках со статической типизацией. Это делает программный код в таких языках легче читаемым (менее "зашумленным", как принято говорить). 

### Пример программы, использующей функции с локальными переменными


### О использовании глобальных переменных

### Использование программами компьютерной памяти
