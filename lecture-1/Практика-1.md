# ПРАКТИКА 1

СОДЕРЖАНИЕ
- [ПРАКТИКА 1](#практика-1)
  - [Подготовка программного окружения для работы с Роботом](#подготовка-программного-окружения-для-работы-с-роботом)
  - [**Технология проектирования "сверху вниз"**](#технология-проектирования-сверху-вниз)
  - [Разбор задачи 2](#разбор-задачи-2)
    - [**Декомпозиция задачи на уровне псевдокода**](#декомпозиция-задачи-на-уровне-псевдокода)
    - [**Программный код главной функции**](#программный-код-главной-функции)
    - [**Реализация вспомогателных функций**](#реализация-вспомогателных-функций)
    - [**Запуск и отладка программного кода**](#запуск-и-отладка-программного-кода)
  - [Разбор задачи 3](#разбор-задачи-3)
    - [**Декомпозиция задачи и соответствующий псевдокод**](#декомпозиция-задачи-и-соответствующий-псевдокод)
    - [**Полученный полный программный код**](#полученный-полный-программный-код)
    - [**Запуск и отладка программного кода**](#запуск-и-отладка-программного-кода-1)
  - [**О самодокументировании библиотечных функций**](#о-самодокументировании-библиотечных-функций)
    - [**Создание библиотечного файла**](#создание-библиотечного-файла)
    - [**Пример получения помощи в REPL по функциям из библиотечного файла**](#пример-получения-помощи-в-repl-по-функциям-из-библиотечного-файла)

-----------------------

[<< README](../README.md)

------------------------

## Подготовка программного окружения для работы с Роботом

См. [здесь](https://github.com/Vibof/HorizonSideRobots.jl/blob/master/content/setup.md)

## **Технология проектирования "сверху вниз"**

Содержание этой технологии было разъяснено [в Лекции 1](Лекция-1.md).

Для её практического усвоения продолжим решение задач.

## Разбор задачи 2
(задача 1 была разобрана на лекции) 

ДАНО: Робот - в произвольной клетке поля (без внутренних перегородок и маркеров)

РЕЗУЛЬТАТ: Робот - в исходном положении, и все клетки по периметру внешней рамки промакированы

Перейдем к решению.

### **Декомпозиция задачи на уровне псевдокода**

```julia
function mark_frame_perimetr!(r::Robot)
    дойти до самого Юга и вернуть сделанное число шагов
    дойти до самого Запада и вернуть сделанное число шагов
    #УТВ: Робот - в Юго-Западном углу

    for sidе - перебор всех 4-х сторон горизонта в ПРАВИЛЬНОМ порядке
        маркировать все клетки, кроме первой, в напраленнии side 
    end 
    #УТВ: По всему периметру прямоугольника стоят маркеры

    сделать уже известное число шагов на Север
    сделать уже известное число шагов на Восток
    #УТВ: Робот - в исходном положении
end
```

### **Программный код главной функции**

Вот соответствующий код главной функции на Julia

```julia
function mark_frame_perimetr!(r::Robot)
    num_vert = moves!(r, Sud)
    num_hor = moves!(r, West)
    #УТВ: Робот - в Юго-Западном углу

    for sidе in (HorizonSide(i) i=0:3) # (Nord, West, Sud, Ost)
        putmarkers!(r, side) 
    end 
    #УТВ: По всему периметру стоят маркеры

    moves!(r, Nord, num_vert)
    moves!(r, Ost, num_hor)
    #УТВ: Робот - в исходном положении
end
```

### **Реализация вспомогателных функций**

```julia
function moves!(r::Robot,side::HorizonSide)
    nun_sreps=0
    while isbborder(r,side)==false
        move!(r,side)
        num_steps+=1
    end
    return num_steps
end

function moves!(r::Robot,side::HorizonSide,num_steps::Int)
    for _ in 1:numsteps # символ "_" заменяет фактически не используемую переменную
        move!(r,side)
    end
end
```
Последние две функции имют одинаковые имена, но различаются количеством своих аргументов, поэтому `Julia` сумеет разобраться какую из них и когда надо вызывать. Это свойство языка называется **множественной диспетчеризацией**. Далеко не все языки программирования обладают этим свойством, например, в `Python` так сделать было бы нельзя.

Следующая функция уже была нами реализована при решении самой первой задачи (см. пример, разбиравшийся на 1-ой леции). И мы могли бы этим сейчас воспользоваться, но для этого надо было бы эту функцию сначала поместить в отдельный библиотечный файл, в котрый мы могли бы помещать также и другие универсально полезные функции. А затем этот библиотечный файл можно было бы использовать в других файлах с помощью функции `include`. Но пока еще мы этого не сделали, то нам придется написать ее повторно (хотя, конечно, это не правильно).

```Julia
function putmarkers!(r::Robot, side::HorizonSide)
    while isborder(r,side)==false
        move!(r,side)
        putmarker!(r)
    end
end
```
-----------------

[<< к началу](#практика-1)

### **Запуск и отладка программного кода**

Все эти определения должны быть помещены в отдельный файл (в этом файле мы и должны были сразу и писать их). Пусть этот файл называется "example-1.jl"

Тогда, что бы приступить к отладке программы, необходимо поместить все наши определения в пространство имен REPL. Для этого из REPL следует выполнить функцию

```julia
julia> include("examle-2.jl")
```
Предвартельно, конечно, мы должны были сделать

```julia
julia> using HorizonSideRobots

julia> r=Robot(animate=true)
```

Модуль HorizonSideRobots экспортирует перечисление HorizonSide, содержащее символы Nord, Sud, Ost, West,  и определения следующих функций:
```julia
    moves!(::Robot, ::HorizonSide)
    moves!(::Robot, ::HorizonSide, ::Int)
    find_border!(::Robot, ::HorizonSide, ::HorizonSide)
    inverse(::HorizonSide)
    putmarkers!(::Robot, ::HorizonSide)
    putmarkers!(r, direction_of_movement, direction_to_border)
```

После этого уже следует приступить к отладке программы. Для этого лучше всего придерживаться технологии отладки "снизу вверх", суть которой была изложена [здесь](https://github.com/Vibof/Robot/blob/master/example.md).

-----------------

[<< к началу](#практика-1)

## Разбор задачи 3

ДАНО: На ограниченном внешней прямоугольной рамкой поле имеется ровно одна внутренняя перегородка в форме прямоугольника. Робот - в произвольной клетке поля между внешней и внутренней перегородками.

РЕЗУЛЬТАТ: Робот - в исходном положении и по всему периметру внутренней перегородки поставлены маркеры.

![пример соответствующей обстановки](situation_3.png)

Перейдем к решению.

### **Декомпозиция задачи и соответствующий псевдокод**

```Julia
function mark_innerrectangle_perimetr!(r::Robot)
    Дойти до упора вниз и вернуть число сделанных шагов
    Дойти до упора влево и вернуть число сделанных шагов
    Дойти до упора вниз и вернуть число сделанных шагов
    #УТВ: Робот - в Юго-западном углу внешней рамки

    Подойти к западной стороне внутренней перегородки (двигаясь змейкой вверх-вниз) и вернуть последнее перед остановой направление движения

    Обойти внутренний прямоугольник, начиная с полученного направления, и расставить по всему его периметру маркеры
    #УТВ: Робот -  у западной границы внутренней прямоугольной перегородки

    Дойти до упора вниз
    Дойти до упора влево
    #УТВ: Робот - в Юго-западном улу внешней рамки

    Сделать известное число шагов вверх
    Сделать известное число шагов вправо
    Сделать известное число шагов вверх
    #УТВ: Робот - в исходном положении
end

Чтобы "Дойти до упора вниз/влево/вниз и вернуть число сделанных шагов" у нас уже от передыдущей задачи есть функция - `moves!(::Robot,::HorizonSide)`. Ее определение мы можем поместить в библиотечный файл, который назовем "roblib.jl", а затем подключить ее к нашему файлу с основной программой с помощью функции `include`. Также мы поступим и с определениями ранее разработанных функции `putmarkers!(r::Robot, side::HorizonSide)`, `inverse(side::HorizonSide)`, `moves!(r::Robot,side::HorizonSide,num_steps::Int)`. И будем делать так и впредь, как только обнаружим, что какя-то наша новая функция получилась достаточно универсальной.

Далее, реализация - "Подойти к западной стороне внутренней перегородки (двигаясь змейкой вверх-вниз) и вернуть последнее перед остановой направление движения", потребует дальнейшей декомпозици. Но сначала придумаем для этой процедуры более короткое имя, и определим необходимые для ее выполнения аргументы (параметры).

function find_border!(r::Robot, direction_to_border::HorizonSide, direction_of_movement::HorizonSide)
    while isborder(r,direction_to_border)==false  
        if isborder(r,direction_of_movement)==false
            move!(r,direction_of_movement)
        else
            move!(r,direction_to_border)
            direction_of_movement=inverse(direction_of_movement)
        end
    end
    #УТВ: непосредственно справа от Робота - внутренняя пергородка
end

Здесь мы обошлись без псевдокода, потому что у нас уже есть подходящие вспомогательные функции, котрые мы смогли сразу же применить

Теперь надо реализовать процедуру "Обойти внутренний прямоугольник, начиная с полученного направления, и расставить по всему его периметру маркеры". Здесь также, сначала придумаем для нее более лаконичное имя, определим необходимые параметры, и, наконец,  произведем дальнейшую декомпозицию.
```

### **Полученный полный программный код**
```julia
function mark_innerrectangle_perimetr!(r::Robot, side::HorizonSide)
    if side == Nord
        # обходить прямоугольник следует по часовой стрелке
        direction_of_movement=(Nord,Ost,Sud, West)
        direction_to_border=(Ost,Sud,West,Nord)
    else 
        # обходить прямоугольник следует против часовой стрелки
        direction_of_movement=(Sud,Ost,Nord,West)
        direction_to_border=(Ost,Nord,West,Sud)
    end

    for i ∈ 1:4   
        # надо ставить маркеры вдоль очередной стороны внутренней перегородки 
        # (перемещаться надо в одном направлении, а следить за перегородеой в - 
        # перпендикулярном ему)
        putmarkers!(r,  direction_of_movement[i], direction_to_border[i]) 
    end
end

Отметим, что у нас главная функция имеет такое же имя, как и у этой последней, но у главной функции был один аргумент, а здесь - их два, так что опять будет действовать "множественная диспетчеризация".

Функция с именем `putmarkers!` у нас тоже уже была, но у той только два аргумента, а у этой новой - их три, так что и тут вступает в действие "множесивенная диспетчеризация". 

Проверку условия в последней функции можно было бы даже выделить в отдельную процедуру

function mark_innerrectangle_perimetr!(r::Robot, side::HorizonSide)
    direction_of_movement, direction_to_border = get_directions(side)
    for i ∈ 1:4   
        putmarkers!(r, direction_of_movement[i], direction_to_border[i]) 
    end
end

get_directions(side::HorizonSide) = if side == Nord  
    # - обход будет по часовой стрелке      
        return (Nord,Ost,Sud, West), (Ost,Sud,West,Nord)
    else # - обход будет против часовой стрелки
        return (Sud,Ost,Nord,West), (Ost,Nord,West,Sud) 
    end

Наконец, мы добрались до последнего определения

function putmarkers!(r::Robot, direction_of_movement::HorizonSide, direction_to_border::HorizonSide)
    while isborder(r,direction_to_border)==true
        move!(r,direction_of_movement)
    end
end
```

-----------------

[<< к началу](#практика-1)

### **Запуск и отладка программного кода**

И так, получилась следующая программа, которую следует поместить в отдельный файл, например, с именем "example-2.jl". Вот содержание этого файла

```Julia
#файл example-3.jl

using HorizonSideRobots
#=
Модуль HorizonSideRobots экспортирует перечисление HorizonSide, содержащее символы Nord, Sud, Ost, West,  и определения следующих функций:
    - moves!(::Robot, ::HorizonSide)
    - moves!(::Robot, ::HorizonSide, ::Int)
    - find_border!(::Robot, ::HorizonSide, ::HorizonSide)
    - inverse(::HorizonSide)
    - putmarkers!(::Robot, ::HorizonSide)
    - putmarkers!(r, direction_of_movement, direction_to_border)
=#

function mark_innerrectangle_perimetr!(r::Robot)
    num_steps=fill(0,3) # - вектор-столбец из 3-х нулей
    for (i,side) in enumerate((Sud,West,Sud))
        num_steps[i]=moves!(r,side)
    end
    #УТВ: Робот - в Юго-западном углу внешней рамки

    side = find_border!(r,Ost,side)
    #УТВ: Робот - у западной границы внутренней перегородки

    mark_innerrectangle_perimetr!(r,side)
    #УТВ: Робот - снова у западной границы внутренней прямоугольной перегородки

    moves!(r,Sud)
    moves!(r,West)
    #УТВ: Робот - в Юго-западном улу внешней рамки

    for (i,side) in enumerate((Nord,Ost,Nord))
        moves!(r,side, num_steps[i])
    end
    #УТВ: Робот - в исходном положении
end

function mark_innerrectangle_perimetr!(r::Robot, side::HorizonSide)
    direction_of_movement, direction_to_border = get_directions(side)
    for i ∈ 1:4   
        putmarkers!(r, direction_of_movement[i], direction_to_border[i]) 
    end
end

get_directions(side::HorizonSide) = if side == Nord  
    # - обход будет по часовой стрелке      
        return (Nord,Ost,Sud, West), (Ost,Sud,West,Nord)
    else # - обход будет против часовой стрелки
        return (Sud,Ost,Nord,West), (Ost,Nord,West,Sud) 
    end
```

-----------------

[<< к началу](#практика-1)

## **О самодокументировании библиотечных функций**

У нас теперь имеется библиотечный файл `roblib.jl`, содержащий определения функций, которые мы предполагаем использовать в будущем многократно. 

Но для того, чтобы можно было пользоваться библиотекой функций необходимо, чтобы библиоткека была с документацией, т.е. чтобы было четкое и исчерпывающее описание того, что конкретно каждая входящая в библиотеку функция делает, какие параметры параметры она принимает, и в каком виде она будет выдавать результат. Без этого пользоваться библиотекой будет крайне проблематично, особенно если она содержит много функций. Потому что, как показывает практика, даже разработчик библиотеки очень быстро забудет о многих важных деталях, не говоря уже о других возможных пользователях библиотеки.

Для решения этой проблемы используется механизм так называемого самодокументирования. Этот механизм состоит в том, что каждая библиотечная функция должна сразу при ее разработке снабжаться специальным многострочным коментарием, заключаемым в тройные кавычки """...""". Этот коментарий должен быть составлен по определенным правилам и содержать всю необходимую для использования функции информацию о ней. Размещаться этот коментарий должен непосредственно перед заголовком самодокументируемой функции.

Если все это будет соблюдено, то как только имя функции попадет в пространство имен REPL (этому пространству имен соответствует встроенный модуль с именем Main), например с помощью функции `include`, информацию о способе использования этой функции можно будет получить с помощью встроенной системы help.

-----------------

[<< к началу](#практика-1)

### **Создание библиотечного файла**

```julia
# Файл roblib.jl

"""
    moves!(r::Robot, side::HorizonSide)

-- перемещает Робота до упора в заданном направлении
"""
moves!(r::Robot, side::HorizonSide) = 
while isborder(r,side) 
    move!(r,side) 
end

"""
    moves!(r::Robot, side::HorizonSide, num_steps::Int)

-- перемещает Робота в заданном направлении на заданное число шагов (если на пути - перегородка, то - ошибка)
"""
moves!(r::Robot, side::HorizonSide, num_steps::Int) = 
for _ in 1:num_steps
    move!(r,side)
end

"""
    find_border!(r::Robot,side_to_border::HorizonSide, side_of_movement::HorizonSide)

-- останавливает робота у перегородки, которая ожидается с направления side_to_border, при движении робота "змейкой" в сторону перегородки (от упора до упора в поперечном этому напавлении). 

-- side_of_movement - начальное "поперечное" направление
"""
find_border!(r::Robot,side_to_border::HorizonSide, side_of_movement::HorizonSide) = 
while isborder(r,side_to_border)==false  
    if isborder(r,side_of_movement)==false
        move!(r,side_of_movement)
    else
        move!(r,side_to_border)
        side_of_movement=inverse(side_of_movement)
    end
end

"""
    inverse(side::HorizonSide)

-- возвращает направлене горизонта, противоположное заданному    
"""
inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2))


"""
    putmarkers!(r::Robot, side::HorizonSide)

-- ставит маркеры, пермещая Робота до упора в заданном направлении (в начальной клетке маркер не ставится)    
"""
putmarkers!(r::Robot, side::HorizonSide) = 
while isborder(r,side)==false
    move!(r,side)
    putmarker!(r)
end

"""
    putmarkers!(r::Robor,side_of_movement::Horizonside,side_to_border::HorizonSide)

-- Ставит маркеры и перемещает Робота в направлении side_of_movement пока рядом с ним в направлении side_to_border имеется перегородка (эти два направления должны быть взаимно перпендикулярными) 
"""
putmarkers!(r::Robor,side_of_movement::Horizonside,side_to_border::HorizonSide) = 
while isborder(r,side_to_border)==true
    move!(r,side_of_movement)
end

``` 

-----------------

[<< к началу](#практика-1)

### **Пример получения помощи в REPL по функциям из библиотечного файла**

Вот как теперь все это должно работать. Сначала из REPL надо подключить библиотечный файл
```julia
julia> include("roblib.jl")

Затем перейти в режим `help`

`julia>?` 

После этого стандартное приглашение REPL изменит свой вид на `help?>`

Теперь можно будет получить помощь по любой библиотечной функции (на равне со встроенными функциями), например

`help?> moves!`

(здесь будет выведена соответствующая информация).
```

-----------------

[<< к началу](#практика-1)
