# ЛЕКЦИЯ 7

- [ЛЕКЦИЯ 7](#лекция-7)
  - [Элементы функционального программирования](#элементы-функционального-программирования)
  - [Функции, как объекты первого класса](#функции-как-объекты-первого-класса)
  - [Анонимные функции](#анонимные-функции)
  - [Функции высщих порядков](#функции-высщих-порядков)
  - [Замыкания (closure)](#замыкания-closure)
  - [Замыкание, возвращаемое из функции](#замыкание-возвращаемое-из-функции)
  - [Стандартная функция высшего порядка map](#стандартная-функция-высшего-порядка-map)
  - [do-синтаксис](#do-синтаксис)
  - [Каррирование](#каррирование)
  - [Операция композиции функций](#операция-композиции-функций)
  - [Операция направления потока данных на "вход" функции](#операция-направления-потока-данных-на-вход-функции)
  
## Элементы функционального программирования

Все программы, которые мы писали до сих пор, были, в основном, написаны в так называемом процедурном, или, говоря иначе, императивном стиле.

Немного мы еще успели коснуться модульного программирования, в котором "стоительными блоками" для программы являются уже не отдельно взятые функции, а модули, сязывающие через глобвльные переменные все функции модуля в единого исполнителя, и командный интерфейс которого определяется функциями, экспортируемыми из модуля.

Собственно императивный стиль предполагает запись некоторой последовательности непосредственно и немедленно исполняемых команд исполнителя.

Однако существует еще и другой подход, называемый функциональным программмрованием. Его отличие от императивного стиля программирования состоит в том, что в нем делается акцент не на программировании немедленно выполненяемых конкретных действий исполнителя, изменяющих его состояние, а на процессе составления описаний таких действий. Т.е. результатом вычисления функций, написанных в функциональном стиле являются другие функции, которые в буддущем (и в конце концов) будут исполнены.

Для дополнительного разъяснения смысла слов "функциональное программирование" полезно также обратиться к аналогиям, имеющимся в математике.

Так в математическом анализе изучаются числовые функции. Например, объектом изучения может быть функция вида `y = f(x)`, гле `x` - числовой аргумент из области ее определения, а `y` - это соответствующее аргументу `x` ее значение.

В процедурном программировании аналогом математической функции `f` является программа, реализующая соответствующую вычислительную процедуру, при этом величины `x` и `y` трактуются как "входные" и "выходные" данные программы.

Но существет раздел математики, называемый функциональным анализом, в котором рассматриваются отображения вида: `h=F(g)`, где `h` и `g` - это не числа, а некоторые функции, при этом отображение `F` обычно называют оператором. Оператор `F` ставит в сооветствие каждой функции `g` из области своего определения, какю-то другую, вообще говоря, функцию `h`, по некоторому правилу. Например, всем известен оператор дифференциирования `D`, который, в частности для функции `x^2` даст функцию `2x`, т.е. `D(x^2)=2x`.

Так вот, если в процедурном программировании мы установили аналогию между программой и функцией `f`, вычисление которой реализует программа, то в функциональном  программировании аналогия устанавливается между некоторым оператором `F` и реализующей его программой, при этом входными и/или выходными данными для неё будут другие программы-функции.

В дальнейшем будут рассмотрены примеры программ, конкретно разъясняющие суть дела, но сначала потребуется дать определения некоторым новым понятиям.

## Функции, как объекты первого класса

В [лекции 5](../5/Лекция-5.md) было дано краткое введение в систему типов Julia, в частности, там было отмечено, что все типы Julia делятся на абстрактные и конкретные типы, и образуют древовидную иерархию. В этом иерархическом дереве конкретные типы находятся в позициях листьев этого дерева, а все остальные узлы иерархического дерева соответствуют абстрактным типам, причем на вершине иерархии находитмся абстрактный тип Any. Создаваемые в программе объекты всегда имеют каой-либо конкретный тип. Абстрактные типы нужны только для поддержания иерархии типов.

В частности в системе типов языка Julia имеется абстрактный тип `Function`, и все функции, как стандартные, так и пользовательские, как таковые являются объектами типов (конкретных), которые, в свою очередь, является подтипами абстрактного типа `Function`.

Можно посмотреть, какие конкретные типы являются подтипами абстрактного типа `Function`:

```julia
julia> subtypes(Function)
9814-element Array{Any,1}:
 Base.BaseDocs.var"#@kw_str"
 Base.Broadcast.var"##broadcasted_kwsyntax#30"
 Base.Broadcast.var"#1#3"
 Base.Broadcast.var"#11#12"
 Base.Broadcast.var"#13#14"
 Base.Broadcast.var"#15#16"
 Base.Broadcast.var"#17#18"
 Base.Broadcast.var"#19#20"
 Base.Broadcast.var"#2#4"
 ⋮
 typeof(∌)
 typeof(∘)
 typeof(≉)
 typeof(⊇)
 typeof(⊈)
 typeof(⊉)
 typeof(⊊)
 typeof(⊋)
 var"#1#2"
 ```

В середине выведенного списка имеется многоточие, означающее, что на экран выведены только несколько первых строчек списка и несколько последних. Весь список получился слишком большим, чтобы поместиться на экране.

Может показаться, что этот список выглядит довольно странно: сначала идут какие-то непонятные имена, типа "#@kw_str", а в самом конце этого списка, хотя и понятные математические значки, но котрые не привычно видеть в языке программирования. Непонятные имена - это имена так называемых **анонимных функций**, про которые разговор еще впереди. 

Матеметические значки, обозначающие разные математические операции, в языке Julia могут быть, на самом деле, именами соответствующих функций, что мы и наблюдаем.
В этот список входят также и все наиболее распространенные математические функции, в частности, тригонометрические, просто они находятся где-то в середине этого списка.

Мы можем в этом убедиться експериментально, например:

```julia
julia> sin
sin (generic function with 12 methods)

julia> typeof(sin)
typeof(sin)

julia> typeof(sin) <: Function
true
```

Полученный выше список конкретных поддтипов абстрактного типа `Function` будет автоматически пополняться всякий раз при введенни каждого нового определения функции.

Вообще функция `typeof(...)` всегда возвращает конкретный тип своего аргумента (в языке Julia каждай тип - это тоже значение, которое само имеет тип - DataType). В примере с функцией `sin` этот возвращаемый тип обозначен как typeof(sin), поскольку какого-то специального имени у него нет (и быть не может, потому что иначе таких имен должно было бы быть практически неограниченное количество). Однако во внутреннем представлении у значения `typeof(sin)` есть, конечно, какой-то код.

Значения любого конкретного типа могут быть записаны в переменную, и функциональные типы - не исключение:

```julia
julia> s = sin
```

Теперь `s` это просто вторе имя функции `sin`:

```julia
julia> sin(π/4)
0.7071067811865475

julia> s(π/4)
0.7071067811865475
```

В этом смысле говорят, что в языке программирования (Julia) функции являются **объектами первого класса**.

Тут имеется в виду, что существуют языки программирования (в настоящее время таких языков уже мало), в которых такие объеты как числа, массивы и т.д. могут быть записаны в переменные, а функции в этом смысле "ограничены в правах", переннных функционального типа в этих языках не существует.

Таким образом, обычные объекты в таких языках - это "объекты первого класса", и функции к их числу не относятся.

А есть языки (это почти все современные языки), где функции уравнены в правах с объектами других типов, в этом смысле и говорят, что функции там являются объектами первого класса (в том смысле, что - не второго).

Все это нужно для того, чтобы функции (как значения) можно было передавать другим функциям в качестве аргументов, и/или чтобы некоторая функция могла бы возвращать функциональное значение, т.е. некоторую функцию.

## Анонимные функции

Кроме именованных функций, с которыми мы до сих пор только и имели дело, бывают еще и, так называемые, **анонимные функции**. Анонимные функции - это функции без имени.

Тут уместна такая аналогия с обычными (не функциональными значениями).
Пусть имеется какая-либо переменная, тогда у нее обязательно есть некоторое значение. Так вот, имя функции  в этом смысле аналогично имени переменной, а анонимная функция - есть значение, которое может быть присвоено некоторой переменной (функционального типа), и тогда эта переменная станет именем функции.

В языке Python, например, для записи анонимных функций используются так называемые лямбда-выражения. В языке Julia для той же цели используется более компактная запись, похожая на общепринятую в математике. Например:

```julia
julia> x -> x^2
#8 (generic function with 1 method)
```

Так представлена функция возвращающая квадрат своего аргумента
Здесь `#8` - это так Julia именовала этот функциональный объект (но это внутреннее имя Julia, оно не предназначено для использования прогаммистом; для программиста эта функция имени не имеет).

Вот пример анонимной функции с двумя аргументами

```julia
julia> (x,y) -> x^2 + y^2
#10 (generic function with 1 method)
```

Если у анонимной функции нет аргумента (функция постоянная), то это записывается так

```julia
julia> () -> pi/2
#14 (generic function with 1 method)
```

Эта функция всегда возвращает значение `pi/2`.

Иногда требуется иметь функцию, у которой формально есть аргумент, но фактически она от него не зависит, тогда такой аргумент не нуждается в имени (при этой определении функции), и запись может быть такой:

```julia
julia> _ -> pi/2
#16 (generic function with 1 method)
```

Значение анонимной функции также может быть присвоено переменной, например

```julia
julia> f = ()->pi/2
#14 (generic function with 1 method)

julia> f()
1.5707963267948966
```

или

```julia
julia> g =  _ -> pi/2
#20 (generic function with 1 method)

julia> g(1)
1.5707963267948966

julia> g(2)
1.5707963267948966
```

Любая анонимная функция также множет быть определена с помощью следующей конструкции:

```julia
function(список_формальных_параметров)
    тело_функции
end
```

Анонимные функции, также как и именованные, являются **вычисляемыми** объектами, т.е. к ним можно применить оператор `(список_аргументов)`, где список аргументов может и отсутствоветь, если для вычисления аргументы не требуются. Например:

```julia
julia> (x->x^2)(2)
4

julia>  function(x,y)
            x+y
        end(1,2)
3
```

## Функции высщих порядков

Функции, принимающие в качестве аргументов другие функции, и/или возвращающие какие-либо функциональные значения, называются **функиями вышего порядка**.

Функциональное программирование, как парадигма программирования, базируется именно на проектировании и использовании функций высшего порядка.

## Замыкания (closure)

Говорят, что функция замыкает переменную, или, просто, что  имеет место "замыкание", если в теле функции есть ссылка на внешнюю пременную (не обязательно глобальную).

Например, определение следующей функции содержит ссылку на внешнюю переменную `a`:

```julia
f(x)=x^2 + a
```

Тогда

```julia
julia> a = 1
julia> f(2)
5

juila> a = 2
julia> f(2)
6
```

Таким образом, переменная `a` и функция `f` - есть одно целое, и его называют замыканием переменной `a` функцией `f`.

Стандартные команды Робота, и некоторые наши "библиотечные" функции требуют среди прочих аргументов, аргумент, содержащий ссылку на Робота. Но Робот обычно один, и поэтому такой комплект аргументов оказывается избыточно гомоздким. Следующие замыкания переменной `robot` позволяют избавиться от этой громоздкости.

```julia
import HorizonSideRobots
move!(side) = HorizonSideRobots.move!(robot,side)
isborder(side) = HorizonSideRobots.isborder(robot,side)
putmarker!() = HorizonSideRobots.putmarker!(robot)
ismarker() = HorizonSideRobots.ismarker!(robot)
temperature() = HorizonSideRobots.temperature(robot)
```

Все эти функции замыкают переменную `robot`. Далее к этому примеру мы еще вернемся в связи с понятием [каррирования](#каррирование)

## Замыкание, возвращаемое из функции

Рассмотрим следующий пример, в котором создается замыкание локальной переменной (аргумента) `num` некоторой функции-оболочки `set_counter(num)`, и которая это замыкание возвращает.

```julia
julia> set_counter(num) = (()->(num+=1))
set_counter (generic function with 1 method)

julia> counter=set_counter(0)
#3 (generic function with 1 method)
```

Последующие вызовы полученного замыкания бут каждый раз увеличивать предыдущее значение замкнутой локальной переменной:

```julia
julia> counter()
1

julia> counter()
2

julia> counter()
3
```

Важно отметить, что локальная переменная `num` функции `set_counter(num)` прекращает своё существование (убирается со стека) в момент завершения выполнения этой функции, т.е. сразу после вызова

```julia
counter = set_counter(0)
```

но поскольку было создано замыкание и потом присвоено переменной `counter`, то это замыкание содержит уже в себе копию той локальной переменной, каждый последующий вызов функции `counter` будет эту копию увеличивать на 1 и возвращать полученное значение, что мы и видели в проведенном эксперименте с этой функцией.

Если тело возвращаемого замыкания многосточное, то удобно  использовать следующий способ записи:

```julia
function closure(...)
    ....
    function(...)
        ...# тут используются локальные переменные функции closure
    end
end
```

Таким образом функция высшего порядка `closure(...)` вернет именно замыкание в виде анонимной функции

```julia
function(...)
    ...
end
```

потому что это, определяющие анонимную функцию выражение, является последним выражением в теле `closure(...)`, которе в сегда и возврашается в языке Julia.

## Стандартная функция высшего порядка map

Стандартная функция высшего порядка `map` характерна для всех языков, поддерживающих функциональный стиль программирования.

Прежде всего отметим, что она позволяет применить некоторую операцию (процедуру) к каждому элементу данного итерируемого объекта и возвращает вектор (или кортеж, - это зависит от типа входного объекта) значений, полученных в результате выполнения этой операции.

Например, каждый элемент итерируемого объекта a (вектора, например) возвести в квадрат (если тип его элементов предполагает возможность возведения их в квадрат) можно так:

```julia
quad_iter = map(x->x^2, iter)
```

где `iter` - это заданный итерируемый объект, x->x^2 - это выражение, определяющее ананимную функцию (квадратичную), в котором x - это просто символ, формалный параметр (этот символ может быть заменен на любой другой, от этого ничего не зависит).

В общем случае вместо квадратичной функции может быть задана любая другая функция одного аргумента. Например,

```julia
julia> map(_->(1,2),(1,2,3))
((1, 2), (1, 2), (1, 2))
```

здесь каждый элемент входного кортежа (1,2,3) был заменен на кортеж (1,2). Причем, поскольку выражение `_->(1,2)` определяет функцию (анонимную), значение которой не зависит от фактического значения аргумента, то вместо имя ее аргумента в этом выражении заменено символом "_".

Функция `map` может использоваться и с другим числом параметров, например, если имеется два итерируемых объекта одной длины, требуется получить вектор, каждый элемент которого есть некоторая (заданная) функция от соответствующих элементов этих двух итерируемых обектов, то можно сделать так:

```julia
result_array = map((x,y)->x^2+y^2, iter_x, iter_y)
```

в частности получится:

```julia
julia> map((x,y)->x^2+y^2, (1,2,3),(4,5,6))
(17, 29, 45)
```

Разумеется вместо (x,y)->x^2+y^2 может быть задана любая другая функция 2-х переменных. 

Итерируемые объекты, передавемые в функцию `map` могут иметь и разную длину, но тогда длина результирующего вектора будет определяться длиной самого короткго из них. Само число входных итерируемых объектов у этой функции также может быть любым, но тогда число аргументов у преобразующей функции, передаваемой в `map` как параметр, должно соответствовать их количеству.

Имеется еще функция map!, которая отличается от map лишь тем, что результат преобразования она не возвращает, а помещает в заранее созданный массив, ссылку на который она должна получать через ссответствующий параметр.

Более подробную информацию об этой функции можно получить обратившись к встроенной справочной системе:

```julia
julia> ?
help?> map!
```

## do-синтаксис

Иногда выражения функций, передаваемых в качестве аргумента в другую функцию, может быть достаточно громоздким, так что записывать соответствующие выражение в позиции соответствующего аргумента вызываемой функции будет неудобно.

Например, пусть каждый элемент заданного числового массива `array` требуется заменить значеинем многочлена
`1+x+2x^2+...+10x^10` вычисленного на значении этого элемента.

Mожно было бы, конечно, сделать так, сначала определть функцию, вычисляющую значение этого многочлена:

```julia
function polynom10(x)
    s=1
    for k in 1:10
        s += k*x^k
    end
    return s
end
```

А потом передать эту функцию в качестве первого аргумента функции `map`:

```julia
new_array = map(polinom10, array)
```

Но можно было и воспользоваться так называемым do-синтаксисом:

```julia
new_array = map(array) do x
    s=1
    for k in 1:10
        s += k*x^k
    end
    return s
end
```

И это будет то же самое, но только более компактно.

В общем случае, если имеется некоторая функция высшего порядка, первый аргумент которой (именно первый) имеет функциональный тип, то выражение, соответствующее фактическому параметру этой функции (которе должн было бы стоять на первой позиции в списке аргументов) можно вынести в `do`-блок, причем сразу после слова `do` на одной с ним строке должны быть перечислены все формальные параметры соответствующего функционального аргумента, а затем должно следовать тело функции, определяющий этот функциональный аргумент.

Таким образом do-блок предназначен для определения функционального аргумента, обязательно находящегося на первой позиции в списке аргументов, произвольной функции высшего порядка.

## Каррирование

Пусть имеется функция от нескольких аргументов, например, `f3(x,y,z)`, и заданы значения ее аргументов `x0`, `y0`, `z0`, тогда

```julia
(x->((y,z)->f3(x,y,z)))(x0) # - это функция 2-х аргументов (y,z)
(x->(y->(z->f3(x,y,z))))(x0)(y0) # - это функция 1-го аргумента (z)
(x->(y->(z->f3(x,y,z))))(x0)(y0)(z0) # - это значение f3(x0,y0,z0)
```

Процедура вычисления функции n аргументов, сводящаяся к последовательности "частичных вычислений" функции (т.е. к приданию части её аргументов конкретных значений), называются **каррированием**.

Например, в командах робота можно избавиться от аргумента `robot` (придать ему данное конкретное значение) еще и следующим образом. В связи с обсуждением [замыканий](#замыкания-closure) мы это уже делали, но сейчас мы сделаем практически тоже самое, но за один прием, так сказать, с помощью специальной функции высшего порядка)

```julia
const HSR = HorizonSideRobots # слово const запрещает в последствии изменять тип переменной HSR
robot_interface(r) = (
    s->HSR.move!(r,s),
    s->HSR.isborder(r,s),
    ()->HSR.putmarker!(r),
    ()->HSR.ismarker(r),
    ()->HSR.temperature(r)
)

robot=Robot()
move!, isborder, putmarker!, ismarker, temperature = robot_interface(robot)
```

При вычислении `robot_interface(robot)` одномоментно происходит частичное вычисление каждой из 5 функций, составляющих командный интерфейс Робота.

Теперь можно будет командовать так, без передачи в соответствующие функции ссылки на Робота:

```julia
move!(Nord)
isborder(Ost)
putmarker!()
ismarker()
temperature()
```

Чтобы лучше понять какая имеется в этом примере связь с понятимем каррирования, ометим следующее

```julia
robot_interface(robot)
```

- возвращает кортеж из 5-и элементов, каждый из которых является функцией, представляющей одну из команд Робота.
  
Тогда, например,

```julia
robot_interface(robot)[1]
```

это будет первая из этих функций, представляющая команду `move!`, и поэтому можно выполнить, например,

```julia
robot_interface(robot)[1](Nord)
```

что приведет к перемещению Робота на один шаг на север.

## Операция композиции функций

Для записи выражений типа

```julia
exp(cos(x))
```

предусмотрена специальная операция композиции функций ∘ (набирается она так: `\circ + tab`), т.е. тоже самое может быть записано как

```julia
(exp∘cos)(x)
```

## Операция направления потока данных на "вход" функции

Например, запись

```julia
1 |> cos |> exp |> println
```

означает то же, что и

```julia
println(exp(cos(1)))
```

Иногда использование такого рода записей может повысить читаемость кода, особенно если имеется длинная цепочка композиций.
